# A Database based implementation of the [core](https://github.com/cyfko/veridot/blob/main/java/veridot-core) API 

The current API especially provide a Database-aware implementation of the core [MetadataBroker](https://github.com/cyfko/veridot/blob/main/java/veridot-core/src/main/java/io/github/cyfko/veridot/core/MetadataBroker.java) Interface.

---

## âœ¨ Features

- ğŸ” **JWT Signing & Verification** using RSA
- ğŸ” **Automatic Key Rotation**
- ğŸ“¬ **Public Key Distribution for decentralized verification** via the provided databases (which may be organised in cluster mode)
- âš™ï¸ **Environment-Based Configuration** with defaults.

---

## ğŸ“¦ Installation

To install **veridot**, follow these steps:

### 1. Add the Dependency

For **Maven**:

```xml

<dependency>
    <groupId>io.github.cyfko</groupId>
    <artifactId>veridot-core</artifactId>
    <version>2.0.0</version>
</dependency>
<dependency>
    <groupId>io.github.cyfko</groupId>
    <artifactId>veridot-databases</artifactId>
    <version>2.0.1</version>
</dependency>
```

For **Gradle**:
```gradle
implementation 'io.github.cyfko:veridot-core:2.0.0'
implementation 'io.github.cyfko:veridot-databases:2.0.1'
```

> âš ï¸ **Important Note**  
> The versioning of the current API follow the [semantic versioning](https://semver.org/) approach.

### 2. Environment Variables (Optional)

The application relies on the following environment variables for configuration:

| Variable Name                   | Description                             | Default Value                                    |
|---------------------------------|-----------------------------------------|--------------------------------------------------|
| `VDOT_KEYS_ROTATION_MINUTES`    | Interval (in minutes) for key rotation  | `1440` (24h)                                     |

## ğŸš€ Using database-backed *MetadataBroker* implementation

This allows your application to persist and retrieve messages (such as signed verification tokens) through a SQL database in a consistent, scalable manner.

This is ideal for:

- Scalable and redundant access in **microservices** and **database clusters**.
- Centralized message storage in **monolithic apps**.

### âœ¨ Features
- âœ… Pluggable table name (safe from SQL injection)
- âœ… Works with major relational databases (PostgreSQL, MySQL, SQL Server, H2, etc.)
- âœ… Async operations using CompletableFuture
- âœ… Auto-create message table on startup (optional)
- âœ… Safe and compliant with SQL standard types (BIGINT, VARCHAR, TEXT, TIMESTAMP)

### ğŸ“¦ Table Structure

```sql
CREATE TABLE broker_messages (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  message_key VARCHAR(255) NOT NULL UNIQUE,
  message_value TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### ğŸ§  Usage

Data signature in the form of transparent token (jwt)

```java
import io.github.cyfko.veridot.core.DataSigner;
import io.github.cyfko.veridot.core.TokenVerifier;
import io.github.cyfko.veridot.core.TokenRevoker;
import io.github.cyfko.veridot.core.impl.BasicConfigurer;
import io.github.cyfko.veridot.core.TokenMode;
import io.github.cyfko.veridot.core.impl.Config;
import io.github.cyfko.veridot.core.impl.GenericSignerVerifier;

import javax.sql.DataSource;

DataSource dataSource = createDataSource();

MetadataBroker metadataBroker = new DatabaseMetadataBroker(dataSource, "broker_messages");

/* Create an instance of GenericSignerVerifier which implements DataSigner, TokenVerifier and TokenRevoker interfaces  */
GenericSignerVerifier genericSignerVerifier = new GenericSignerVerifier(metadataBroker);

DataSigner dataSigner = genericSignerVerifier;
TokenVerifier tokenVerifier = genericSignerVerifier;
TokenRevoker tokenRevoker = genericSignerVerifier;

/* Configure how to generate and track the token */
BasicConfigurer configurer = BasicConfigurer.builder()
        .useMode(TokenMode.jwt)
        .trackedBy(5)       // Tracker identity, used for revocation purposes.
        .validity(60 * 5)   // Valid for 5 minutes.
        .build();

/* Generate the token (sign the data of interest) */
String data = "john.doe@example.com";
String token = dataSigner.sign(data, configurer);                    // Generate the JWT token embedding the data.

/* Verify the token (extracting the data of interest) */
String verifiedData = tokenVerifier.verify(token, String::toString); // Verifying the JWT token and extracting the embedded data as a String.

assertNotNull(verifiedData);

assertEquals(data, verifiedData);

/* Revoke the token when necessary */
tokenRevoker.revoke(token); // Tokens can also be revoked by passing the tracker ID instead of the token itself.

assertThrows(BrokerExtractionException .class, () -> tokenVerifier.verify(token, String::toString));
```
#### âš ï¸ Security & Best Practices
- The tableName is validated to prevent SQL injection. Only alphanumeric and underscores are allowed.
- `DatabaseBroker` automatically ensures the metadataBroker table exists on first usage. It inspects the database metadata and creates the table if it is missing â€” no extra setup required.

#### ğŸ—ï¸ Cluster/Distributed Considerations
In sharded database or clustered setups:

- All nodes/services should point to the same logical message store (or synchronized replicas)
- `message_key` column with `UNIQUE` constraint ensures uniqueness without needing global coordination
- If you use DB-level replication, `DatabaseBroker` naturally benefits from it (high availability)

#### âœ… Tested with:
- PostgreSQL 13+
- MySQL 8+
- SQL Server 2019+
- MariaDB 11+
- H2 (dev mode)

## ğŸ“Œ Requirements

- Java >= 17

---

## ğŸ” Security Considerations

- Uses RSA 4096
- Only valid keys within the expiration window are accepted
